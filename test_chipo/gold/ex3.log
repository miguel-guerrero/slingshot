-------------- verilog --------------
//----------------------------------------------------------------------------
// adder
//----------------------------------------------------------------------------
module adder (
.   input cin,
.   input [9:0] x,
.   input [9:0] y,
.   output reg [10:0] sm,
.   input clk,
.   input rst_n
);

reg [10:0] sm_r;
reg sm_zero_r;

always @(*) begin : combo_logic
.   sm <= x + y + cin;
end

always @(posedge clk or negedge rst_n) begin
.   if (~rst_n) begin
.   .   sm_r <= 0;
.   .   sm_zero_r <= 0;
.   end
.   else begin : registering
.   .   sm_r <= sm;
.   .   sm_zero_r <= sm == 0;
.   end
end

endmodule

-------------- repr --------------
Module('adder', IOs=[In(typ=BitVec(width=1), name='cin'), In(typ=BitVec(width=10), name='x'), In(typ=BitVec(width=10), name='y'), Out(typ=BitVec(width=11), name='sm'), Clock(name='clk'), Reset(name='rst_n')], params=[], body=[Combo(body=Block(SigAssign(Out(typ=BitVec(width=11), name='sm'), ((In(typ=BitVec(width=10), name='x') + In(typ=BitVec(width=10), name='y')) + In(typ=BitVec(width=1), name='cin'))), name='combo_logic')), Clocked(Clock(name='clk'), reset=Reset(name='rst_n'), autoReset=True).Body(Block(If(~(Reset(name='rst_n'))).Then(Block(SigAssign(Out(typ=BitVec(width=11), name='sm_r'), CInt(0)), SigAssign(Out(typ=BitVec(width=1), name='sm_zero_r'), CInt(0)))).Else(Block(SigAssign(Out(typ=BitVec(width=11), name='sm_r'), Out(typ=BitVec(width=11), name='sm')), SigAssign(Out(typ=BitVec(width=1), name='sm_zero_r'), (Out(typ=BitVec(width=11), name='sm') == CInt(0))), name='registering'))))])
